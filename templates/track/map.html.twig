{% extends 'base.html.twig' %}
{% block title %}Hein's Global Tracker{% endblock %}

{% block body %}
<div style="max-width: 1200px; margin: 0 auto; padding: 16px;">
  <h1 style="margin: 0 0 10px 0;">Hein's Global Tracker</h1>
  <div id="meta" style="margin: 0 0 12px 0; opacity: .8;"></div>

  <div id="map" style="height: 78vh; border-radius: 12px; overflow: hidden;"></div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const map = L.map('map', {
    worldCopyJump: true,
    tap: true,              // helps mobile
  }).setView([0, 0], 2);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  const meta = document.getElementById('meta');

  let drawnLayers = [];

  function clearDrawn() {
    drawnLayers.forEach(layer => map.removeLayer(layer));
    drawnLayers = [];
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function autoLink(s) {
    if (!s) return '';

    // Escape everything first
    let escaped = escapeHtml(s);

    // Convert URLs into links (http/https only)
    escaped = escaped.replace(
      /(https?:\/\/[^\s<]+)/g,
      '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
    );

    // Preserve line breaks
    return escaped.replace(/\n/g, '<br>');
  }

  async function loadTrack() {
    const res = await fetch('/api/trackpoints', { cache: 'no-store' });
    if (!res.ok) throw new Error('API error');

    const json = await res.json();

    const segments = json.segments || [];
    const points = json.points || [];
    const latestUtc = json.latestUtc || null;

    clearDrawn();

    if (segments.length === 0 || points.length === 0) {
      meta.textContent = 'No points yet.';
      return;
    }

    // 1) Draw polylines (make them more visible on mobile)
    const lines = [];
    segments.forEach(seg => {
      if (seg.length >= 2) {
        const poly = L.polyline(seg, { weight: 4 }).addTo(map);
        lines.push(poly);
        drawnLayers.push(poly);
      } else if (seg.length === 1) {
        const dot = L.circleMarker(seg[0], { radius: 8, weight: 2, fillOpacity: 0.9 }).addTo(map);
        drawnLayers.push(dot);
      }
    });

    // 2) Fit bounds
    if (lines.length) {
      const group = L.featureGroup(lines);
      map.fitBounds(group.getBounds(), { padding: [30, 30] });
    }

    // 3) Points as big, tap-friendly circleMarkers with popups
    // Find latest point (assumes points are sorted by time asc)
    const lastPoint = points[points.length - 1];

    const pointMarkers = [];

    points.forEach(p => {
      const isLatest =
        lastPoint && p.lat === lastPoint.lat && p.lon === lastPoint.lon && p.addedOn === lastPoint.addedOn;

      const marker = L.circleMarker([p.lat, p.lon], {
        radius: isLatest ? 8 : 6,  // bigger for latest
        weight: isLatest ? 3 : 2,
        fillOpacity: 0.9,
        interactive: true
      }).addTo(map);

      let popup = '';

      // a) Timestamp
      if (p.addedOn) {
        popup += `<strong>${escapeHtml(p.addedOn)}</strong>`;
      }

      // b) Lat / Lon first
      popup += `<br>lat: ${p.lat.toFixed(5)}, lon: ${p.lon.toFixed(5)}`;

      // c) Message (clickable links + line breaks)
      if (p.message) {
        popup += `<br><br>${autoLink(p.message)}`;
      }

      marker.bindPopup(popup, {
        maxWidth: 320,
        closeButton: true,
        autoPan: true
      });

      // Mobile: open popup on tap
      marker.on('click', () => marker.openPopup());
      marker.on('touchstart', () => marker.openPopup());

      drawnLayers.push(marker);
      pointMarkers.push(marker);
    });

    // Optionally open latest popup by default (nice on mobile)
    // (Comment out if you don't want this behavior)
    const latestMarker = pointMarkers[pointMarkers.length - 1];
    if (latestMarker) {
      latestMarker.openPopup();
    }

    // 4) Meta line
    const timeText = latestUtc ? `${latestUtc} UTC` : '';
    meta.textContent =
      `Latest: ${lastPoint.lat.toFixed(5)}, ${lastPoint.lon.toFixed(5)}${timeText ? ' @ ' + timeText : ''}`;
  }

  loadTrack().catch((e) => {
    console.error(e);
    meta.textContent = 'Failed to load points. Check /api/trackpoints.';
  });
</script>
{% endblock %}
