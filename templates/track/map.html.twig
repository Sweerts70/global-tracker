{% extends 'base.html.twig' %}
{% block title %}Hein's Global Tracker{% endblock %}

{% block body %}
<div style="max-width: 1200px; margin: 0 auto; padding: 16px;">
  <h1 style="margin: 0 0 10px 0;">Hein's Global Tracker</h1>
  <div id="meta" style="margin: 0 0 12px 0; opacity: .8;"></div>

  <div id="map" style="height: 78vh; border-radius: 12px; overflow: hidden;"></div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  /* General: nicer touch behavior */
  #map { touch-action: pan-x pan-y; }

  /* Make links/buttons easier to tap in popups */
  .leaflet-popup-content a {
    display: inline-block;
    padding: 6px 0;
  }

  /* Mobile / coarse pointer tweaks */
  @media (pointer: coarse), (max-width: 768px) {
    .leaflet-container {
      font-size: 16px;              /* larger base text */
    }
    .leaflet-popup-content {
      margin: 14px 16px;            /* more padding */
      line-height: 1.35;
      font-size: 30px;
    }
    .leaflet-popup-content-wrapper {
      border-radius: 14px;
    }
    .leaflet-popup-close-button {
      width: 44px;                  /* Apple-ish tap size */
      height: 44px;
      font-size: 28px;
      line-height: 44px;
    }
  }
</style>

<script>

  const isCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;

  const map = L.map('map', {
    worldCopyJump: true,
    tap: true,
    tapTolerance: isCoarsePointer ? 25 : 15,  // bigger tolerance on phones
    preferCanvas: true                        // helps performance if you have many points
  }).setView([0, 0], 2);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  const meta = document.getElementById('meta');

  let drawnLayers = [];

  function clearDrawn() {
    drawnLayers.forEach(layer => map.removeLayer(layer));
    drawnLayers = [];
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function autoLink(s) {
    if (!s) return '';

    // Escape everything first
    let escaped = escapeHtml(s);

    // Convert URLs into links (http/https only)
    escaped = escaped.replace(
      /(https?:\/\/[^\s<]+)/g,
      '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
    );

    // Preserve line breaks
    return escaped.replace(/\n/g, '<br>');
  }

  async function loadTrack() {
    const res = await fetch('/api/trackpoints', { cache: 'no-store' });
    if (!res.ok) throw new Error('API error');

    const json = await res.json();

    const segments = json.segments || [];
    const points = json.points || [];
    const latestUtc = json.latestUtc || null;

    clearDrawn();

    if (segments.length === 0 || points.length === 0) {
      meta.textContent = 'No points yet.';
      return;
    }

    // 1) Draw polylines (make them more visible on mobile)
    const lines = [];
    segments.forEach(seg => {
      if (seg.length >= 2) {
        const poly = L.polyline(seg, { weight: 4 }).addTo(map);
        lines.push(poly);
        drawnLayers.push(poly);
      } else if (seg.length === 1) {
        const dot = L.circleMarker(seg[0], { radius: 8, weight: 2, fillOpacity: 0.9 }).addTo(map);
        drawnLayers.push(dot);
      }
    });

    // 2) Fit bounds
    if (lines.length) {
      const group = L.featureGroup(lines);
      map.fitBounds(group.getBounds(), { padding: [30, 30] });
    }

    // 3) Points as big, tap-friendly circleMarkers with popups
    // Find latest point (assumes points are sorted by time asc)
    const lastPoint = points[points.length - 1];

    const pointMarkers = [];

    points.forEach(p => {
    const isLatest =
        lastPoint && p.lat === lastPoint.lat && p.lon === lastPoint.lon && p.addedOn === lastPoint.addedOn;

    // Visible marker size
    const visibleRadius = isCoarsePointer ? (isLatest ? 8 : 6) : (isLatest ? 6 : 4);

    // Hit area (invisible / nearly invisible but interactive)
    const hitRadius = isCoarsePointer ? 20 : 12;

    // 1) visible dot
    const dot = L.circleMarker([p.lat, p.lon], {
        radius: visibleRadius,
        weight: isLatest ? 3 : 2,
        fillOpacity: 0.9,
        interactive: false   // IMPORTANT: dot is not the tap target
    }).addTo(map);

    // 2) invisible hit target on top
    const hit = L.circleMarker([p.lat, p.lon], {
        radius: hitRadius,
        weight: 0,
        opacity: 0,
        fillOpacity: 0.01,   // keep it effectively invisible, but still clickable
        interactive: true
    }).addTo(map);

    let popup = '';

    if (p.addedOn) popup += `<strong>${escapeHtml(p.addedOn)}</strong>`;
    popup += `<br>lat: ${p.lat.toFixed(5)}, lon: ${p.lon.toFixed(5)}`;
    if (p.message) popup += `<br><br>${autoLink(p.message)}`;

    hit.bindPopup(popup, {
        maxWidth: isCoarsePointer ? 460 : 320,
        closeButton: true,
        autoPan: true,
        autoPanPadding: isCoarsePointer ? [24, 24] : [12, 12],
        className: isCoarsePointer ? 'popup-mobile' : ''
    });

    // Single event that works for mouse + touch
    hit.on('pointerdown', (e) => {
        // Prevent map from also interpreting this as a drag start
        L.DomEvent.stop(e);
        hit.openPopup();
    });

    drawnLayers.push(dot, hit);
    pointMarkers.push(hit); // keep "hit" markers in your list for "open latest"
    });

    // Optionally open latest popup by default (nice on mobile)
    // (Comment out if you don't want this behavior)
    const latestMarker = pointMarkers[pointMarkers.length - 1];
    if (latestMarker) {
      latestMarker.openPopup();
    }

    // 4) Meta line
    const timeText = latestUtc ? `${latestUtc} UTC` : '';
    meta.textContent =
      `Latest: ${lastPoint.lat.toFixed(5)}, ${lastPoint.lon.toFixed(5)}${timeText ? ' @ ' + timeText : ''}`;
  }

  loadTrack().catch((e) => {
    console.error(e);
    meta.textContent = 'Failed to load points. Check /api/trackpoints.';
  });
</script>
{% endblock %}
